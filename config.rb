require 'extensions/sitemap'

###
# Compass
###

# Change Compass configuration
# compass_config do |config|
#   config.output_style = :compact
# end

###
# Page options, layouts, aliases and proxies
###

# Per-page layout changes:
#
# With no layout
# page "/path/to/file.html", :layout => false
#
# With alternative layout
# page "/path/to/file.html", :layout => :otherlayout
#
# A path which all have the same layout
# with_layout :admin do
#   page "/admin/*"
# end

# Proxy pages (http://middlemanapp.com/dynamic-pages/)
# proxy "/this-page-has-no-template.html", "/template-file.html", :locals => {
#  :which_fake_page => "Rendering a fake page with a local variable" }

###
# Helpers
###

# Automatic image dimensions on image_tag helper
# activate :automatic_image_sizes

# Reload the browser automatically whenever files change
activate :livereload

activate :sitemap_generator

# Methods defined in the helpers block are available in templates
# helpers do
#   def some_helper
#     "Helping"
#   end
# end

class Episode < Struct.new(:title, :synopsis, :cover_image_base, :url, :free, :length)
  def title_with_subscriber_tag
    [].tap do |parts|
      parts << title
      parts << "[Subscribers Only]" unless free?
    end.join(" ")
  end

  def cover_image_url
    cover_image_base + "_600x338.png"
  end

  def small_cover_image_url
    cover_image_base + "_300x169.png"
  end

  def free?
    free
  end

  def paid?
    !free?
  end
end

helpers do
  def nav_active_class(page)
    page_classes === page ? 'active' : ''
  end

  def latest_episode
    episodes.last
  end

  def raw_hours_and_minutes(total_seconds)
    total_minutes = total_seconds / 60
    hours = total_minutes / 60
    minutes = total_minutes - (hours * 60)
    seconds = total_seconds - (minutes * 60) - (hours * 60 * 60)
    [hours, minutes, seconds]
  end

  def hours_and_minutes(total_seconds)
    hours, minutes, seconds = raw_hours_and_minutes(total_seconds)
    pretty_minutes = minutes.to_s.rjust(2, "0")
    pretty_seconds = seconds.to_s.rjust(2, "0")
    "#{hours}:#{pretty_minutes}:#{pretty_seconds}"
  end

  def schema_duration(total_seconds)
    hours, minutes, seconds = raw_hours_and_minutes(total_seconds)
    "T#{minutes}M#{seconds}S"
  end

  def total_time
    episodes.map(&:length).inject(:+)
  end

  def free_episodes
    episodes.select do |episode|
      episode.free?
    end
  end

  def url(path)
    "http://elixirsips.com/#{path}"
  end

  def episodes
    [
      Episode.new("001: Introduction and Installing Elixir",
                  "A quick introduction to the screencast, followed by an Erlang / Elixir installation walkthrough.",
                  "001_Introduction_and_Installing_Elixir_Cover_Image",
                 "/episodes/001_introduction_and_installing_elixir.html",
                 true,
                 346),
      Episode.new("002: Basic Elixir",
                  "A quick overview of some of the basic types in Elixir: Atoms, Numbers, Lists, Tuples, Regexes, and Booleans...",
                  "002_Basic_Elixir_Cover_Image",
                  "/episodes/002_basic_elixir.html",
                  false,
                  336),
      Episode.new("003: Pattern Matching",
                  "A discussion of pattern matching in Elixir.",
                  "003_Pattern_Matching_Screenshot",
                  "/episodes/003_pattern_matching.html",
                  false,
                  348),
      Episode.new("004: Functions",
                  "An overview of functions in Elixir: Defining them, calling them, and using them as first-class types.",
                  "004_Functions_Screenshot",
                  "/episodes/004_functions.html",
                  false,
                  330),
      Episode.new("005: Mix and Modules",
                  "Using Mix to generate an app, and defining modules and functions.",
                  "005_Modules_Screenshot",
                  "/episodes/005_modules.html",
                  false,
                  417),
      Episode.new("006: Unit Testing",
                  "Test Driving a module into existence in Elixir.",
                  "006_Testing_Screenshot",
                  "/episodes/006_testing.html",
                  false,
                  1313),
      Episode.new("007: Dynamo, Part 1",
                  "The first part to an introduction to building a web application in Elixir using Dynamo.",
                  "007_Dynamo_Part_1_Screenshot",
                  "/episodes/007_dynamo_part_1.html",
                  true,
                  458),
      Episode.new("008: Dynamo, Part 2",
                  "An introduction to Amnesia for persistence, and a brief pointer to Ecto.",
                  "008_Dynamo_Part_2_Screenshot",
                  "/episodes/008_dynamo_part_2.html",
                  false,
                  685),
      Episode.new("009: Dynamo, Part 3",
                  "Integrating Amnesia and Dynamo to create a web app with a persistence layer.",
                  "009_Dynamo_Part_3_Screenshot",
                  "/episodes/009_dynamo_part_3.html",
                  false,
                  406),
      Episode.new("010: List Comprehensions",
                  "An overview of list comprehensions in Elixir, or: buildings lists from lists (of lists?).",
                  "010_List_Comprehensions_Screenshot",
                  "/episodes/010_list_comprehensions.html",
                  false,
                  299),
      Episode.new("011: Records",
                  "An overview of records in Elixir; what they are, how they're used.",
                  "011_Records_Screenshot",
                  "/episodes/011_records.html",
                  false,
                  234),
      Episode.new("012: Processes",
                  "A discussion of processes in Elixir, and general concurrent programming with messaging.",
                  "012_Processes_Screenshot",
                  "/episodes/012_processes.html",
                  false,
                  589),
      Episode.new("013: Processes, Part 2",
                  "Modeling a Bank Account in Elixir using processes: encapsulating state, CQRS, and Event Sourcing.",
                  "013_Processes_Part_2_Screenshot",
                  "/episodes/013_processes_part_2.html",
                  false,
                  624),
      Episode.new("014: OTP Part 1 - Servers",
                  "Introduction to OTP, and building and testing a module that implements GenServer.Behaviour.",
                  "014_OTP_Part_1_Servers_Screenshot",
                  "/episodes/014_otp_part_1_servers.html",
                  false,
                  555),
      Episode.new("015: OTP Part 2 - Finite State Machines",
                  "An overview of what Finite State Machines are good for, and implementing GenFSM.Behaviour to build an acceptor state machine.",
                  "015_OTP_Part_2_Finite_State_Machines_Screenshot",
                  "/episodes/015_otp_part_2_finite_state_machines.html",
                  false,
                  775),
      Episode.new("016: Pipe Operator",
                  "An introduction to the pipe operator, and an example app mimicking a unix pipeline.",
                  "016_Pipe_Operator_Screenshot",
                  "/episodes/016_pipe_operator.html",
                  false,
                  802),
      Episode.new("017: Enum, Part 1",
                  "A brief overview of the first portion of the Enum module from the standard library",
                  "017_Enum_Part_1_Screenshot",
                  "/episodes/017_enum_part_1.html",
                  false,
                  303),
      Episode.new("018: Enum, Part 2",
                  "A brief overview of the second portion of the Enum module from the standard library",
                  "018_Enum_Part_2_Screenshot",
                  "/episodes/018_enum_part_2.html",
                  false,
                  323),
      Episode.new("019: Enum, Part 3",
                  "Wrapping up the Enum module",
                  "019_Enum_Part_3_Screenshot",
                  "/episodes/019_enum_part_3.html",
                  false,
                  459),
      Episode.new("020: OTP, Part 3 - GenEvent",
                  "Getting started with the GenEvent Behaviour",
                  "020_OTP_Part_3_GenEvent_Screenshot",
                  "/episodes/020_otp_part_3_gen_event.html",
                  false,
                  642),
      Episode.new("021: ZeldaCat, Part 2",
                  "More practice with GenEvent",
                  "021_ZeldaCat_Part_2_Screenshot",
                  "/episodes/021_zeldacat_part_2.html",
                  false,
                  434),
      Episode.new("022: OTP, Part 4 - Supervisors",
                  "How supervisors can help you 'let it crash.'",
                  "022_OTP_Part_4_Supervisors_Screenshot",
                  "/episodes/022_otp_part_4_supervisors.html",
                  false,
                  596),
      Episode.new("023: OTP, Part 5 - Supervisors and Persistent State",
                  "Making a supervised process's state live through a crash.",
                  "023_OTP_Part_5_Supervisors_and_Persistent_State_Screenshot",
                  "/episodes/023_otp_part_5_supervisors_and_persistent_state.html",
                  false,
                  711),
      Episode.new("024: Ecto, Part 1",
                  "An introduction to using Ecto and Postgres for persistence.",
                  "024_Ecto_Part_1_Screenshot",
                  "/episodes/024_ecto_part_1.html",
                  true,
                  525),
      Episode.new("025: Ecto, Part 2 - Dwitter",
                  "Overhauling our Dynamo webapp to use Ecto for its persistence layer.",
                  "025_Ecto_Part_2_Dwitter_Screenshot",
                  "/episodes/025_ecto_part_2_dynamo.html",
                  false,
                  580),
      Episode.new("026: Dict, Part 1",
                  "A brief overview of the first portion of the Dict module.",
                  "026_Dict_Part_1_Screenshot",
                  "/episodes/026_dict_part_1.html",
                  false,
                  389),
      Episode.new("027: Dict, Part 2",
                  "A brief overview of the second portion of the Dict module.",
                  "027_Dict_Part_2_Screenshot",
                  "/episodes/027_dict_part_2.html",
                  false,
                  291),
      Episode.new("028: Parsing XML",
                  "A glimpse into XML parsing in Elixir, by way of interoperating with an Erlang module.",
                  "028_Parsing_XML_Screenshot",
                  "/episodes/028_parsing_xml.html",
                  true,
                  560),
      Episode.new("029: HTTP Clients",
                  "A survey of the HTTP Client landscape.",
                  "029_HTTP_Clients_Screenshot",
                  "/episodes/029_http_clients.html",
                  false,
                  457),
      Episode.new("030: ExActor",
                  "Simplified generation of generic servers.",
                  "030_ExActor_Screenshot",
                  "/episodes/030_exactor.html",
                  false,
                  336),
      Episode.new("031: TCP Servers",
                  "Building network servers in Elixir using Erlang's `:gen_tcp` module.",
                  "031_TCP_Servers_Screenshot",
                  "/episodes/031_tcp_servers.html",
                  false,
                  219),
      Episode.new("032: Command Line Scripts",
                  "Basic Introduction to writing Elixir scripts that can be invoked and passed arguments from the command line.",
                  "032_Command_Line_Scripts_Screenshot",
                  "/episodes/032_command_line_scripts.html",
                  false,
                  394),
      Episode.new("033: Pry",
                  "Using IEx.pry to inspect and debug a running process.",
                  "033_Pry_Screenshot",
                  "/episodes/033_pry.html",
                  false,
                  98),
      Episode.new("034: Elixiak",
                  "An ActiveRecord-like wrapper for Riak in Elixir",
                  "034_Elixiak_Screenshot",
                  "/episodes/034_elixiak.html",
                  false,
                  98),
      Episode.new("035: Weber",
                  "Building a basic web app with the Weber MVC framework.",
                  "035_Weber_Screenshot",
                  "/episodes/035_weber.html",
                  false,
                  775),
      Episode.new("036: Weber, Part 2 - Performance",
                  "Building a simple cache, and a performance comparison with node.js and ruby.",
                  "036_Weber_Part_2_Screenshot",
                  "/episodes/036_weber_part_2.html",
                  false,
                  1072),
      Episode.new("037: ExLager",
                  "Fantastic logging for your application.",
                  "037_ExLager_Screenshot",
                  "/episodes/037_exlager.html",
                  false,
                  314),
      Episode.new("038: Binaries - Deconstructing and Constructing",
                  "Deconstructing and Constructing lists of bits in Elixir.",
                  "038_Binaries_Deconstructing_and_Constructing_Screenshot",
                  "/episodes/038_binaries_deconstructing_and_constructing.html",
                  false,
                  188),
      Episode.new("039: Binaries - Deconstructing an IP Packet",
                  "Deconstructing an IP Packet in Elixir.",
                  "039_Binaries_Deconstructing_an_IP_Packet_Screenshot",
                  "/episodes/039_binaries_deconstructing_an_ip_packet.html",
                  false,
                  407),
      Episode.new("040: Bitwise",
                  "Manipulating bits; typically useful for wire protocols.",
                  "040_Bitwise_Screenshot",
                  "/episodes/040_bitwise.html",
                  false,
                  195),
      Episode.new("041: File, Part 1",
                  "A brief overview of the first portion of the File module from the standard library.",
                  "041_File_Part_1_Screenshot",
                  "/episodes/041_file_part_1.html",
                  false,
                  195),
      Episode.new("042: File, Part 2",
                  "An overview of the second half of the File module from the standard library.",
                  "042_File_Part_2_Screenshot",
                  "/episodes/042_file_part_2.html",
                  false,
                  234),
      Episode.new("043: Releases With Relex",
                  "Making your Elixir application redistributable using Erlang releases.",
                  "043_Releases_With_Relex_Screenshot",
                  "/episodes/043_releases_with_relex.html",
                  true,
                  252),
      Episode.new("044: Distribution",
                  "Sending messages from one Elixir node to another.",
                  "044_Distribution_Screenshot",
                  "/episodes/044_distribution.html",
                  false,
                  120),
      Episode.new("045: Distribution, Part 2",
                  "Sending messages to remote machines, and Joe Armstrong's favorite program.",
                  "045_Distribution_Part_2_Screenshot",
                  "/episodes/045_distribution_part_2.html",
                  false,
                  190),
      Episode.new("046: Markdown Server, Part 1",
                  "Building an HTTP Server to render Markdown files, using the Phoenix web framework.",
                  "046_Markdown_Server_Part_1_Screenshot",
                  "/episodes/046_markdown_server_part_1.html",
                  false,
                  408),
      Episode.new("047: Markdown Server, Part 2",
                  "Writing an integration test suite and dealing with macros for the first time.",
                  "047_Markdown_Server_Part_2_Screenshot",
                  "/episodes/047_markdown_server_part_2.html",
                  false,
                  560),
      Episode.new("048: Markdown Server, Part 3",
                  "Using Eml for markup, and bringing in Compass and Zurb Foundation for styles.",
                  "048_Markdown_Server_Part_3_Screenshot",
                  "/episodes/048_markdown_server_part_3.html",
                  false,
                  525),
      Episode.new("049: Markdown Server, Part 4",
                  "Building a poor man's livereload system using inotify and websockets.",
                  "049_Markdown_Server_Part_4_Screenshot",
                  "/episodes/049_markdown_server_part_4.html",
                  false,
                  471),
      Episode.new("050: Markdown Server, Part 5",
                  "Accepting environment variables for configuration and filtering out files we don't want. Plus, a call to action to build BEAM Toolbox.",
                  "050_Markdown_Server_Part_5_Screenshot",
                  "/episodes/050_markdown_server_part_5.html",
                  false,
                  255),
      Episode.new("051: BEAM Toolbox, Part 1",
                  "Introducing BEAM Toolbox and starting work on the data layer.",
                  "051_BEAM_Toolbox_Part_1_Screenshot",
                  "/episodes/051_beam_toolbox_part_1.html",
                  false,
                  478),
      Episode.new("052: BEAM Toolbox, Part 2",
                  "Further work on the data layer, and  introducing defoverridable.",
                  "052_BEAM_Toolbox_Part_2_Screenshot",
                  "/episodes/052_beam_toolbox_part_2.html",
                  false,
                  599),
      Episode.new("053: BEAM Toolbox, Part 3",
                  "Adding an integration testing layer that drives a browser using Hound, extracting a Controller helper, and adding Project pages.",
                  "053_BEAM_Toolbox_Part_3_Screenshot",
                  "/episodes/053_beam_toolbox_part_3.html",
                  false,
                  460),
      Episode.new("054: Maps, Part 1",
                  "An introduction to maps, a new feature in Erlang R17 and Elixir 0.13",
                  "054_Maps_Part_1_Screenshot",
                  "/episodes/054_maps_part_1.html",
                  true,
                  171),
      Episode.new("055: Maps, Part 2 - Structs",
                  "Introducing structs and demonstrating how they can take the place of public Records.",
                  "055_Maps_Part_2_Screenshot",
                  "/episodes/055_maps_part_2.html",
                  true,
                  143),
      Episode.new("056: Migrating Records to Maps",
                  "Converting a production use of Records to use maps instead.",
                  "056_Migrating_Records_To_Maps_Screenshot",
                  "/episodes/056_migrating_records_to_maps.html",
                  false,
                  179),
      Episode.new("057: BEAM Toolbox, Part 4",
                  "Moving our ad-hoc, tuple-based data layer to one powered by maps/structs.",
                  "057_BEAM_Toolbox_Part_4_Screenshot",
                  "/episodes/057_beam_toolbox_part_4.html",
                  false,
                  514),
      Episode.new("058: BEAM Toolbox, Part 5",
                  "Building a module that caches our GitHub data for a given project.",
                  "058_BEAM_Toolbox_Part_5_Screenshot",
                  "/episodes/058_beam_toolbox_part_5.html",
                  false,
                  319),
      Episode.new("059: Custom Mix Tasks",
                  "Looking at building a basic mix task, and how you can go about testing it.",
                  "059_Custom_Mix_Tasks_Screenshot",
                  "/episodes/059_custom_mix_tasks.html",
                  false,
                  177),
      Episode.new("060: New Style Comprehensions",
                  "An overview of the revamped comprehensions in Elixir v0.13",
                  "060_New_Style_Comprehensions_Screenshot",
                  "/episodes/060_new_style_comprehensions.html",
                  false,
                  158),
      Episode.new("061: Plug",
                  "Exploring Elixir's library for building composable web application modules.",
                  "061_Plug_Screenshot",
                  "/episodes/061_plug.html",
                  false,
                  367),
      Episode.new("062: Quickie Synth",
                  "Using processes, gs, and shelling out to `sox` to build an Elixir-based synthesizer module.",
                  "062_Quickie_Synth_Screenshot",
                  "/episodes/062_quickie_synth.html",
                  true,
                  584),
      Episode.new("063: Tracing",
                  "A quick tour of the `dbg` module from Erlang, and its tracing features.",
                  "063_Tracing_Screenshot",
                  "/episodes/063_tracing.html",
                  false,
                  233),
      Episode.new("064: Digraph",
                  "A look at using the `digraph`module from the Erlang standard library to implement pathfinding on a map.",
                  "064_Digraphs_Screenshot",
                  "/episodes/064_digraph.html",
                  false,
                  657),
      Episode.new("065: SSH",
                  "Using Erlang's `ssh` module to provide ssh access to a shell running your Elixir code.",
                  "065_SSH_Screenshot",
                  "/episodes/065_ssh.html",
                  false,
                  126),
      Episode.new("066: Plug.Static",
                  "Serving static files without an opaque and complicated-looking cowboy handler.",
                  "066_Plug_Static_Screenshot",
                  "/episodes/066_plug_static.html",
                  false,
                  120),
      Episode.new("067: Deploying to Heroku",
                  "Using HashNuke's Elixir buildpack for Heroku to deploy BEAM Toolbox.  Also, a brief intro to ExConf.",
                  "067_Deploying_to_Heroku_Screenshot",
                  "/episodes/067_deploying_to_heroku.html",
                  false,
                  383),
      Episode.new("068: Port",
                  "Interacting with external programs as if they were simple processes.",
                  "068_Port_Screenshot",
                  "/episodes/068_port.html",
                  false,
                  238),
      Episode.new("069: Observer",
                  "A graphical tool for inspection of a running Erlang/Elixir system and its processes.",
                  "069_Observer_Screenshot",
                  "/episodes/069_observer.html",
                  false,
                  238),
      Episode.new("070: Hex",
                  "Elixir's new package manager.",
                  "070_Hex_Screenshot",
                  "/episodes/070_hex.html",
                  false,
                  178),
      Episode.new("071: Wx",
                  "Building a GUI calculator using Erlang's native wx bindings.",
                  "071_Wx_Screenshot",
                  "/episodes/071_wx.html",
                  false,
                  496),
      Episode.new("072: WxCalc, Part 2",
                  "Implementing our calculator's logic and wiring it up to wx events.",
                  "072_WxCalc_Part_2_Screenshot",
                  "/episodes/072_wxcalc_part_2.html",
                  false,
                  1126),
      Episode.new("073: Process Dictionaries",
                  "Process-local state that you likely should never use :)",
                  "073_Process_Dictionaries_Screenshot",
                  "/episodes/073_process_dictionaries.html",
                  false,
                  140),
      Episode.new("074: ETS",
                  "Erlang term storage - a queryable database for your processes to store terms in.",
                  "074_ETS_Screenshot",
                  "/episodes/074_ets.html",
                  false,
                  498),
      Episode.new("075: DETS",
                  "A disk-based version of ETS with a few restrictions.",
                  "075_DETS_Screenshot",
                  "/episodes/075_dets.html",
                  false,
                  269),
      Episode.new("076: Streams",
                  "A brief overview of Elixir's 'lazy, composable Enumerables'",
                  "076_Streams_Screenshot",
                  "/episodes/076_streams.html",
                  false,
                  188),
      Episode.new("077: Exceptions and Errors",
                  "Manually raising exceptions, handling them, defining your own, and using them idiomatically.",
                  "077_Exceptions_and_Errors_Screenshot",
                  "/episodes/077_exceptions_and_errors.html",
                  false,
                  137),
      Episode.new("078: Agents",
                  "A simple abstraction around state",
                  "078_Agents_Screenshot",
                  "/episodes/078_agents.html",
                  false,
                  344),
      Episode.new("079: Tasks",
                  "An abstraction for computing a value in the background and receiving the value later.",
                  "079_Tasks_Screenshot",
                  "/episodes/079_tasks.html",
                  false,
                  311),
      Episode.new("080: erlubi",
                  "A client for the Ubigraph visualization server, and an easy way to view a BEAM application's supervision tree in 3D.",
                  "080_erlubi_Screenshot",
                  "/episodes/080_erlubi.html",
                  false,
                  303),
      Episode.new("081: EEx",
                  "Elixir's built-in templating language, useful for embedding Elixir code inside of a string.",
                  "081_EEx_Screenshot",
                  "/episodes/081_eex.html",
                  true,
                  216),
      Episode.new("082: Protocols",
                  "A fantastic method for polymorphism in Elixir.  Pairs well with structs.  Slight oaky flavor.",
                  "082_Protocols_Screenshot",
                  "/episodes/082_protocols.html",
                  false,
                  238),
      Episode.new("083: pg2",
                  "A replacement for the `pg` module that has some better semantics for distribution.",
                  "083_pg2_Screenshot",
                  "/episodes/083_pg2.html",
                  false,
                  332),
      Episode.new("084: PCM Audio",
                  "Generating PCM Audio and making some noise",
                  "084_PCM_Audio_Screenshot",
                  "/episodes/084_pcm_audio.html",
                  true,
                  307),
      Episode.new("085: Apex",
                  "Awesome Print for Elixir.  An easy way to get insight into unfamiliar data structures.",
                  "085_Apex_Screenshot",
                  "/episodes/085_apex.html",
                  false,
                  110),
      Episode.new("086: put_in and get_in",
                  "(and friends) Easy access to deeply nested data structures.",
                  "086_put_in_and_get_in_Screenshot",
                  "/episodes/086_put_in_and_get_in.html",
                  false,
                  412),
      Episode.new("087: WordCloud",
                  "Using Elixir to do a word frequency count on a corpus of text and generate input for a WordCloud generator.",
                  "087_WordCloud_Screenshot",
                  "/episodes/087_word_cloud.html",
                  false,
                  656),
      Episode.new("088: Porcelain",
                  "External Process interaction like the Port module but both simpler and more powerful.",
                  "088_Porcelain_Screenshot",
                  "/episodes/088_porcelain.html",
                  false,
                  603),
      Episode.new("089: Protocol Buffers",
                  "Easy cross-language serialization and deserialization of data structures using Google's Protocol Buffers and exprotobuf.",
                  "089_Protocol_Buffers_Screenshot",
                  "/episodes/089_protocol_buffers.html",
                  false,
                  240),
      Episode.new("090: Websockets Terminal",
                  "Taking advantage of Phoenix's native websockets support to build an in-browser bash terminal proxy.",
                  "090_Websockets_Terminal_Screenshot",
                  "/episodes/090_websockets_terminal.html",
                  false,
                  780),
      Episode.new("091: Test Coverage",
                  "Exploring test coverage report generation, using both Erlang's `cover` application and the Coverex tool.",
                  "091_Test_Coverage_Screenshot",
                  "/episodes/091_test_coverage.html",
                  false,
                  155),
      Episode.new("092: Link Extractor",
                  "Using poolboy to build a service for extracting data from a set of links and collecting them into memory for viewing later.",
                  "092_Link_Extractor_Screenshot",
                  "/episodes/092_link_extractor.html",
                  false,
                  836),
      Episode.new("093: Link Extractor, Part 2",
                  "Using Phoenix to build an HTTP API for posting links into the system, and a page to view posted links.",
                  "093_Link_Extractor_Part_2_Screenshot",
                  "/episodes/093_link_extractor_part_2.html",
                  false,
                  557),
      Episode.new("094: Link Extractor, Part 3",
                  "Deploying our application to a VPS from scratch and pushing in our first message.",
                  "094_Link_Extractor_Part_3_Screenshot",
                  "/episodes/094_link_extractor_part_3.html",
                  false,
                  398),
      Episode.new("095: Link Extractor, Part 4",
                  "Fixing some bugs and setting up a Zapier integration.",
                  "095_Link_Extractor_Part_4_Screenshot",
                  "/episodes/095_link_extractor_part_4.html",
                  false,
                  799),
      Episode.new("096: Arduino Motor Driver",
                  "An unusually formatted episode discussing an ad hoc serial protocol for controlling an Arduino Motor Controller.",
                  "096_Arduino_Motor_Driver_Screenshot",
                  "/episodes/096_arduino_motor_driver.html",
                  false,
                  362),
      Episode.new("097: BEAM Toolbox, Part 6",
                  "Resurrecting the Toolbox with an Ecto-based data layer from scratch, and synchronizing data with the Hex API.",
                  "097_BEAM_Toolbox_Part_6_Screenshot",
                  "/episodes/097_beam_toolbox_part_6.html",
                  false,
                  382),
      Episode.new("098: Contributing to Open Source",
                  "In which we contribute to the elixir codebase and open a pull request.",
                  "098_Contributing_to_Open_Source_Screenshot",
                  "/episodes/098_contributing_to_open_source.html",
                  false,
                  994),
      Episode.new("099: BEAM Toolbox, Part 7",
                  "Managing relationships in Ecto, and integrating Ecto into a Phoenix application.",
                  "099_BEAM_Toolbox_Part_7_Screenshot",
                  "/episodes/099_beam_toolbox_part_7.html",
                  false,
                  524),
      Episode.new("100: BEAM Toolbox, Part 8",
                  "Making the BEAM Toolbox a bit more useful, including adding in Disqus support.",
                  "100_BEAM_Toolbox_Part_8_Screenshot",
                  "/episodes/100_beam_toolbox_part_8.html",
                  false,
                  587),
      Episode.new("101: BEAM Toolbox, Part 9",
                  "Building a CLI utility for categorizing our projects as a Mix task.",
                  "101_BEAM_Toolbox_Part_9_Screenshot",
                  "/episodes/101_beam_toolbox_part_9.html",
                  false,
                  743),
      Episode.new("102: BEAM Toolbox, Part 10",
                  "Building a projects listing page, and reviewing some changes to the toolbox.",
                  "102_BEAM_Toolbox_Part_10_Screenshot",
                  "/episodes/102_beam_toolbox_part_10.html",
                  false,
                  357),
      Episode.new("103: BEAM Toolbox, Part 11",
                  "Switching to the expression style in Ecto, and using Phoenix's new routing helpers because we must.",
                  "103_BEAM_Toolbox_Part_11_Screenshot",
                  "/episodes/103_beam_toolbox_part_11.html",
                  false,
                  260),
      Episode.new("104: Ruby to Elixir via BERT-RPC",
                  "Trivial interop between Ruby and Elixir processes using BERT-RPC.",
                  "104_Ruby_to_Elixir_Via_BERTRPC_Screenshot",
                  "/episodes/104_ruby_to_elixir_via_bertrpc.html",
                  false,
                  246),
      Episode.new("105: Farkov Chain",
                  "Generating killer marketing strategies with Elixir",
                  "105_Farkov_Chain_Screenshot",
                  "/episodes/105_farkov_chain.html",
                  false,
                  753),
      Episode.new("106: Text Parsing",
                  "Building a parser for a custom text format.",
                  "106_Text_Parsing_Screenshot",
                  "/episodes/106_text_parsing.html",
                  false,
                  855),
      Episode.new("107: Phoenix Release",
                  "Using `exrm` to build a release of the BEAM Toolbox webapp, for deployment.",
                  "107_Phoenix_Release_Screenshot",
                  "/episodes/107_phoenix_release.html",
                  false,
                  236),
      Episode.new("108: Release Upgrades",
                  "Upgrading a running app to a new version without losing state.",
                  "108_Release_Upgrades_Screenshot",
                  "/episodes/108_release_upgrades.html",
                  false,
                  293),
      Episode.new("109: Socket",
                  "A pleasant abstraction around `gen_tcp`, `gen_udp`, `gen_sctp`, and `ssl`.",
                  "109_Socket_Screenshot",
                  "/episodes/109_socket.html",
                  false,
                  366),
      Episode.new("110: ExTwitter",
                  "A library for interacting with the Twitter API, using standard requests or the streaming responses.",
                  "110_ExTwitter_Screenshot",
                  "/episodes/110_ex_twitter.html",
                  false,
                  180),
      Episode.new("111: ExTwitter, Part 2",
                  "Streaming a Twitter search to the browser, because Phoenix Channels are meant to be paired with Elixir Streams, I promise.",
                  "111_ExTwitter_Part_2_Screenshot",
                  "/episodes/111_ex_twitter_part_2.html",
                  false,
                  296),
      Episode.new("112: Benchfella",
                  "A pleasant-to-use benchmarking tool that includes graph output.",
                  "112_Benchfella_Screenshot",
                  "/episodes/112_benchfella.html",
                  false,
                  287),
      Episode.new("113: Monitoring Network Traffic",
                  "Using libpcap from Elixir to see the stream of data passing across your computer's network interface.",
                  "113_Monitoring_Network_Traffic_Screenshot",
                  "/episodes/113_monitoring_network_traffic.html",
                  false,
                  275),
      Episode.new("114: Wx Keyboard Events",
                  "Handling keyboard input in a wx application.",
                  "114_Wx_Keyboard_Events_Screenshot",
                  "/episodes/114_wx_keyboard_events.html",
                  false,
                  329),
      Episode.new("115: Wx Extris Continued",
                  "Making pieces fall and drawing the game board.",
                  "115_Wx_Extris_Continued_Screenshot",
                  "/episodes/115_wx_extris_continued.html",
                  false,
                  349),
      Episode.new("116: Wx Extris Part 3 - Refactoring",
                  "Turning a gigantic module into something a little more sensible and well-factored.",
                  "116_Wx_Extris_Part_3_Refactoring_Screenshot",
                  "/episodes/116_wx_extris_part_3_refactoring.html",
                  false,
                  470),
      Episode.new("117: Wx Extris Part 4 - Testing",
                  "Writing some tests and implementing board boundary collision.",
                  "117_Wx_Extris_Part_4_Testing_Screenshot",
                  "/episodes/117_wx_extris_part_4_testing.html",
                  false,
                  684),
      Episode.new("118: Wx Extris Part 5",
                  "Defining the bottom game board boundary and providing the next shape when needed.",
                  "118_Wx_Extris_Part_5_Screenshot",
                  "/episodes/118_wx_extris_part_5.html",
                  false,
                  345),
      Episode.new("119: Wx Extris Part 6",
                  "Introducing multiple processes into the game, and running the render loop separately from the game logic.",
                  "119_Wx_Extris_Part_6_Screenshot",
                  "/episodes/119_wx_extris_part_6.html",
                  false,
                  726),
      Episode.new("120: Wx Extris Part 7",
                  "Introducing collision detenction and cleaning up the renderer / game board data structure.",
                  "120_Wx_Extris_Part_7_Screenshot",
                  "/episodes/120_wx_extris_part_7.html",
                  false,
                  2117),
      Episode.new("121: Wx Extris Part 8",
                  "Test-driven implementation of clearing full lines off of the board.",
                  "121_Wx_Extris_Part_8_Screenshot",
                  "/episodes/121_wx_extris_part_8.html",
                  false,
                  413),
      Episode.new("122: SDL",
                  "Using the SDL library for graphics from your Elixir programs.",
                  "122_SDL_Screenshot",
                  "/episodes/122_sdl.html",
                  false,
                  351),
      Episode.new("123: SDL Extris",
                  "Writing a renderer for the Tetris clone using SDL.",
                  "123_SDL_Extris_Screenshot",
                  "/episodes/123_sdl_extris.html",
                  false,
                  1139),
      Episode.new("124: Typespecs",
                  "Layering type information over your functions to aid users and static analysis tools, and to catch errors.",
                  "124_Typespecs_Screenshot",
                  "/episodes/124_typespecs.html",
                  false,
                  226),
      Episode.new("125: Dialyzer",
                  "Letting the computer (rather than logs or users) tell you when you've written crap code.",
                  "125_Dialyzer_Screenshot",
                  "/episodes/125_dialyzer.html",
                  false,
                  289),
      Episode.new("126: Piping Into Elixir",
                  "Handling typical unix-script style stdin and stdout pipes trivially from your Elixir scripts.",
                  "126_Piping_Into_Elixir_Screenshot",
                  "/episodes/126_piping_into_elixir.html",
                  false,
                  96),
      Episode.new("127: SSH Client Commands",
                  "Becoming an SSH client and sending commands to an SSH server with Elixir.",
                  "127_SSH_Client_Commands_Screenshot",
                  "/episodes/127_ssh_client_commands.html",
                  false,
                  107),
      Episode.new("128: Managing Docker",
                  "Programmatically interacting with Docker using Elixir and erldocker.",
                  "128_Managing_Docker_Screenshot",
                  "/episodes/128_managing_docker.html",
                  false,
                  182),
      Episode.new("129: egd",
                  "A module in the Erlang Standard Library meant for doing basic graphics.",
                  "129_egd_Screenshot",
                  "/episodes/129_egd.html",
                  false,
                  121),
      Episode.new("130: Extris Web Client",
                  "Using Phoenix's websockets to build a JavaScript canvas-based renderer and interaction module for Extris games running in processes on the server.",
                  "130_Extris_Web_Client_Screenshot",
                  "/episodes/130_extris_web_client.html",
                  false,
                  774),
      Episode.new("131: ExProf",
                  "An Elixir profiler, useful for finding where your program is spending its time.",
                  "131_ExProf_Screenshot",
                  "/episodes/131_exprof.html",
                  false,
                  223),
      Episode.new("132: Randomness in the Erlang VM",
                  "An exploration of where our randomness in Tetris went so horribly wrong, along with an exposition of how to think about which process your code is running in, and why that's important.",
                  "132_Randomness_in_the_Erlang_VM_Screenshot",
                  "/episodes/132_randomness_in_the_erlang_vm.html",
                  false,
                  245),
      Episode.new("133: Boltun - Postgres Listen+Notify",
                  "An Elixir package providing fantastically simple support for Postgres's built-in pubsub notifications.",
                  "133_Boltun_Postgres_Listen_Notify_Screenshot",
                  "/episodes/133_boltun_postgres_listen_notify.html",
                  false,
                  370),
      Episode.new("134: Elastic Search with Tirexs",
                  "An easy way to interact with ElasticSearch.",
                  "134_Elastic_Search_with_Tirexs_Screenshot",
                  "/episodes/134_elastic_search_with_tirexs.html",
                  false,
                  449),
      Episode.new("135: Benchwarmer",
                  "Another benchmarking tool, with a little bit less setup required.",
                  "135_Benchwarmer_Screenshot",
                  "/episodes/135_benchwarmer.html",
                  false,
                  113),
      Episode.new("136: Interfacing with Asterisk",
                  "Using the `erlagi` application from Elixir to control the logic of an extension in a PBX system via Asterisk's AGI protocol.",
                  "136_Interfacing_with_Asterisk_Screenshot",
                  "/episodes/136_interfacing_with_asterisk.html",
                  false,
                  365),
      Episode.new("137: Asterisk AGI with Elixir",
                  "Building out an erlagi handler module in Elixir that interacts with a remote HTTP API.",
                  "137_Asterisk_AGI_with_Elixir_Screenshot",
                  "/episodes/137_asterisk_agi_with_elixir.html",
                  false,
                  230),
      Episode.new("138: Monitors and Links",
                  "Two of the core building blocks that the Erlang VM provides.  I'd neglected discussing them until now.  Oops.",
                  "138_Monitors_and_Links_Screenshot",
                  "/episodes/138_monitors_and_links.html",
                  false,
                  260),
      Episode.new("139: hexdocs",
                  "Elixir's package manager, hex.pm, also provides a documentation server for elixir packages.  We'll see how to push documentation up.",
                  "139_hexdocs_Screenshot",
                  "/episodes/139_hexdocs.html",
                  false,
                  152),
      Episode.new("140: gopher",
                  "Using `goma`, which is essentially WebMachine for The Internet Gopher Protocol, to build an elixir-powered gopher server.",
                  "140_gopher_Screenshot",
                  "/episodes/140_gopher.html",
                  false,
                  467),
      Episode.new("141: Set",
                  "Elixir ships with a Set behaviour, and a default HashSet implementation.",
                  "141_Set_Screenshot",
                  "/episodes/141_set.html",
                  false,
                  114),
      Episode.new("142: escript",
                  "Building quick 'binaries' after a fashion using Elixir's tooling.",
                  "142_escript_Screenshot",
                  "/episodes/142_escript.html",
                  false,
                  178),
      Episode.new("143: phoenix_generator",
                  "A project that adds code generation to Phoenix for building models, controllers, templates, and channels.",
                  "143_phoenix_generator_Screenshot",
                  "/episodes/143_phoenix_generator.html",
                  false,
                  385),
      Episode.new("144: Erlang's `calendar` module",
                  "Interacting with Erlang's native date and time types.",
                  "144_erlangs_calendar_module_Screenshot",
                  "/episodes/144_erlangs_calendar_module.html",
                  false,
                  188),
      Episode.new("145: good_times",
                  "An elixir library for trivially specifying relative dates and times.",
                  "145_good_times_Screenshot",
                  "/episodes/145_good_times.html",
                  false,
                  192),
      Episode.new("146: mailman",
                  "Easily send emails, parse emails, and verify email related features in your tests using this One Neat Trick.",
                  "146_mailman_Screenshot",
                  "/episodes/146_mailman.html",
                  false,
                  290),
      Episode.new("147: webassembly",
                  "Generate markup from blocks of elixir code, in the style of _why the lucky stiff's markaby.",
                  "147_webassembly_Screenshot",
                  "/episodes/147_webassembly.html",
                  false,
                  216),
      Episode.new("148: ejabberd with Elixir",
                  "Getting started interacting with a battle-hardened XMPP chat server by writing Elixir modules for it.",
                  "148_ejabberd_with_elixir_Screenshot",
                  "/episodes/148_ejabberd_with_elixir.html",
                  false,
                  381),
      Episode.new("149: ejabberd Packet Filters",
                  "Modifying messages inside of our ejabberd server, specifically - making everyone yell at each other.",
                  "149_ejabberd_packet_filters_Screenshot",
                  "/episodes/149_ejabberd_packet_filters.html",
                  false,
                  504),
      Episode.new("150: JInterface",
                  "Talking to Elixir from Java",
                  "150_JInterface_Screenshot",
                  "/episodes/150_jinterface.html",
                  false,
                  623),
      Episode.new("151: System Information",
                  "Exploring a running Erlang system using tools from the shell.",
                  "151_system_information_Screenshot",
                  "/episodes/151_system_information.html",
                  false,
                  379),
      Episode.new("152: erlang_js",
                  "Evaluating javascript on a SpiderMonkey interpreter and getting back Erlang terms.",
                  "152_erlang_js_Screenshot",
                  "/episodes/152_erlang_js.html",
                  false,
                  210),
      Episode.new("153: Phoenix APIs and CORS",
                  "Building a basic API with Phoenix, and allowing remote domains to access it from the browser.",
                  "153_Phoenix_APIs_and_CORS_Screenshot",
                  "/episodes/153_phoenix_apis_and_cors.html",
                  false,
                  465),
      Episode.new("154: inet",
                  "Basic TCP/IP interactions built into Erlang's kernel application for you.",
                  "154_inet_Screenshot",
                  "/episodes/154_inet.html",
                  false,
                  149),
      Episode.new("155: OAuth2 Code Spelunking",
                  "A dig through Sonny Scroggins' example of integrating a Phoenix application with GitHub via his OAuth2 package.",
                  "155_OAuth2_Code_Spelunking_Screenshot",
                  "/episodes/155_OAuth2_Code_Spelunking.html",
                  false,
                  263),
      Episode.new("156: Interacting with Amazon's APIs with erlcloud",
                  "A comically brief overview of erlcloud and evidence that it does, in fact, work for me.",
                  "156_Interacting_with_Amazons_APIs_with_erlcloud_Screenshot",
                  "/episodes/156_interacting_with_amazon_apis_with_erlcloud.html",
                  false,
                  128),
      Episode.new("157: Playing with the Code Module, Part 1 - eval_string",
                  "Exploring the standard library's Code module's `eval_string` function for fun and whatnot.",
                  "157_Playing_with_the_Code_Module_Part_1_Screenshot",
                  "/episodes/157_playing_with_the_code_module_part_1.html",
                  false,
                  186),
      Episode.new("158: SOAP with Detergentex",
                  "Using the `detergentex` library, which wraps the erlang `detergent` library, to interact with SOAP services in Elixir.",
                  "158_SOAP_with_Detergentex_Screenshot",
                  "/episodes/158_soap_with_detergentex.html",
                  false,
                  197),
      Episode.new("159: Simple One for One Supervisors",
                  "Getting a dynamically spawned process into a supervision tree to avoid orphaned processes, among other things.",
                  "159_Simple_One_for_One_Supervisors_Screenshot",
                  "/episodes/159_simple_one_for_one_supervisors.html",
                  false,
                  458),
      Episode.new("160: MultiDef",
                  "A less-verbose way to define multiple function clauses, courtesy of Dave Thomas.",
                  "160_MultiDef_Screenshot",
                  "/episodes/160_multidef.html",
                  false,
                  108),
      Episode.new("161: Building a Cron System, Part 1",
                  "Building a parser for cron-style job definitions.",
                  "161_Building_a_Cron_System_Part_1_Screenshot",
                  "/episodes/161_building_a_cron_system_part_1.html",
                  false,
                  754),
      Episode.new("162: Building a Cron System, Part 2",
                  "Determining if a given time is matched by a Schedule.",
                  "162_Building_a_Cron_System_Part_2_Screenshot",
                  "/episodes/162_building_a_cron_system_part_2.html",
                  false,
                  589),
      Episode.new("163: Building a Cron System, Part 3",
                  "Executing our jobs on their schedule.  Bonus intro to defdelegate and ExUnit's `@tag`s.",
                  "163_Building_a_Cron_System_Part_3_Screenshot",
                  "/episodes/163_building_a_cron_system_part_3.html",
                  false,
                  645),
      Episode.new("164: Fractals",
                  "Exploring L Systems, on our way to generating fractals.",
                  "164_Fractals_Screenshot",
                  "/episodes/164_fractals.html",
                  false,
                  648),
      Episode.new("165: Accounting 101",
                  "Modeling a double-entry ledger. Terribly. And then discussing what went wrong.",
                  "165_Accounting_101_Screenshot",
                  "/episodes/165_accounting_101.html",
                  false,
                  1345),
      Episode.new("166: Implementing Logo",
                  "Implementing the Logo graphical programming language in Elixir with wxWidgets.  In this episode we just implement the underlying GenServer.",
                  "166_Implementing_Logo_Screenshot",
                  "/episodes/166_implementing_logo.html",
                  true,
                  824),
      Episode.new("167: Implementing Logo, Part 2 (the drawening)",
                  "Building a renderer for our Logo interpreter.",
                  "167_Implementing_Logo_Part_2_Screenshot",
                  "/episodes/167_implementing_logo_part_2.html",
                  true,
                  705),
      Episode.new("168: Continuous Integration",
                  "Using Semaphore CI to automatically test a Phoenix application each time we push new code.",
                  "168_Continuous_Integration_Screenshot",
                  "/episodes/168_continuous_integration.html",
                  true,
                  444),
      Episode.new("169: Fractals, Part 2",
                  "Combining our L Systems and our Logo Interpreter to explore drunk sierpinski triangles.",
                  "169_Fractals_Part_2_Screenshot",
                  "/episodes/169_fractals_part_2.html",
                  false,
                  493),
      Episode.new("170: Building a Slack Bot",
                  "Using Elixir to build a bot that can respond to messages in our Slack groups.",
                  "170_Building_a_Slack_Bot_Screenshot",
                  "/episodes/170_building_a_slack_bot.html",
                  false,
                  406),
      Episode.new("171: Erlang 18 and Time",
                  "Learning how to replace calls to `:erlang.now` with the new API for various use cases.  Plus an introduction to the kerl erlang release manager.",
                  "171_Erlang_18_and_time_Screenshot",
                  "/episodes/171_erlang_18_and_time.html",
                  false,
                  441),
      Episode.new("172: Arc File Uploads",
                  "Using the `arc` library to enable simple file uploads and image manipulation and versioning in your Phoenix applications.",
                  "172_Arc_File_Uploads_Screenshot",
                  "/episodes/172_arc_file_uploads.html",
                  false,
                  393),
      Episode.new("173: Continuous Deployment",
                  "Using SemaphoreCI to automatically deploy your Phoenix application after the tests run successfully.",
                  "173_Continuous_Deployment_Screenshot",
                  "/episodes/173_continuous_deployment.html",
                  false,
                  308),
      Episode.new("174: ElixirFriends - Saving Tweets with Streams and Filters",
                  "Building a Phoenix Application that stores select tweets for display, applying filters, using Twitter's streaming search.",
                  "174_ElixirFriends_Saving_Tweets_with_Streams_and_Filters_Screenshot",
                  "/episodes/174_elixir_friends_saving_tweets_with_streams_and_filters.html",
                  false,
                  380),
      Episode.new("175: Pagination with Ecto and Phoenix",
                  "Using Scrivener to paginate Ecto queries and display pagination controls on our web pages.",
                  "175_Pagination_with_Ecto_and_Phoenix_Screenshot",
                  "/episodes/175_pagination_with_ecto_and_phoenix.html",
                  false,
                  634),
      Episode.new("176: Prettying Up ElixirFriends",
                  "Adding SemanticUI to ElixirFriends and making it look a little bit better.  Also, we beef up the paginator to know what's active.",
                  "176_Prettying_Up_ElixirFriends_Screenshot",
                  "/episodes/176_prettying_up_elixir_friends.html",
                  false,
                  707),
      Episode.new("177: Audio Visualizer",
                  "Using ports and wx to build a visualizer for an audio stream.",
                  "177_Audio_Visualizer_Screenshot",
                  "/episodes/177_audio_visualizer.html",
                  false,
                  938),
      Episode.new("178: Memory Leaks",
                  "Using :observer to find memory leaks in your system, because the BEAM's basically on OS.",
                  "178_Memory_Leaks_Screenshot",
                  "/episodes/178_memory_leaks.html",
                  false,
                  265),
      Episode.new("179: Rules Engine",
                  "Building a Rules Engine and benchmarking a couple of different processing options.",
                  "179_Rules_Engine_Screenshot",
                  "/episodes/179_rules_engine.html",
                  false,
                  1278),
      Episode.new("180: Collectable",
                  "Implementing the Collectable protocol to clean up a common pattern in our code.",
                  "180_Collectable_Screenshot",
                  "/episodes/180_collectable.html",
                  false,
                  355),
      Episode.new("181: Native Compilation with HiPE",
                  "Taking further advantage of the power given to us by the almighty BEAM to get faster code for free. Hype hype hype!",
                  "181_Native_Compilation_with_HiPE_Screenshot",
                  "/episodes/181_native_compilation_with_hipe.html",
                  false,
                  474),
      Episode.new("182: Phoenix API",
                  "Building out an API endpoint for ElixirFriends in Phoenix",
                  "182_Phoenix_API_Screenshot",
                  "/episodes/182_phoenix_api.html",
                  false,
                  350),
      Episode.new("183: React with Phoenix",
                  "Building a React application that interfaces with our Phoenix API for ElixirFriends.",
                  "183_React_with_Phoenix_Screenshot",
                  "/episodes/183_react_with_phoenix.html",
                  false,
                  472),
      Episode.new("184: React with Phoenix Channels",
                  "Pushing new posts to ElixirFriends into our React application's state using Phoenix Channels.",
                  "184_React_Phoenix_Channels_Screenshot",
                  "/episodes/184_react_with_phoenix_channels.html",
                  false,
                  404),
      Episode.new("185: Mix Archives",
                  "Using Mix to build an Erlang Archive Format file and install it as a local archive.",
                  "185_Mix_Archives_Screenshot",
                  "/episodes/185_mix_archives.html",
                  false,
                  118),
      Episode.new("186: Automatically Connecting Nodes",
                  "Using Erlang's sys.config file to tell our application to wire a couple of nodes together automatically, and seeing that Phoenix Channels support distribution out of the box.",
                  "186_Automatically_Connecting_Nodes_Screenshot",
                  "/episodes/186_automatically_connecting_nodes.html",
                  false,
                  214),
      Episode.new("187: Compiling a Custom AST Into Elixir Functions",
                  "Taking advantage of Elixir's amazing metaprogramming support to build our own AST and compile it into running functions.",
                  "187_Compiling_a_Custom_AST_Into_Elixir_Functions_Screenshot",
                  "/episodes/187_compiling_a_custom_ast_into_elixir_functions.html",
                  false,
                  534),
      Episode.new("188: ElixirScript",
                  "Because writing Elixir is far preferable to writing JavaScript.",
                  "188_ElixirScript_Screenshot",
                  "/episodes/188_elixirscript.html",
                  false,
                  333),
      Episode.new("189: .iex.exs",
                  "Customizing your IEx prompt for productivity and aesthetic purposes.",
                  "189_.iex.exs_Screenshot",
                  "/episodes/189_.iex.exs.html",
                  false,
                  182),
      Episode.new("190: Testing Phoenix Channels",
                  "Looking at the facilities Phoenix provides to assist in writing tests for your channels.",
                  "190_Testing_Phoenix_Channels_Screenshot",
                  "/episodes/190_testing_phoenix_channels.html",
                  false,
                  228),
      Episode.new("191: Interesting I/O",
                  "Building an ANSI Tetris renderer for the TTY using iolists.",
                  "191_Interesting_IO_Screenshot",
                  "/episodes/191_interesting_io.html",
                  false,
                  727),
      Episode.new("192: Interesting I/O, Part 2 - Input with `tty_sl`",
                  "Using the underlying port driver that the Erlang 'REPL' uses to handle terminal-based input one character at a time.",
                  "192_Interesting_IO_Part_2_Input_with_tty_sl_Screenshot",
                  "/episodes/192_interesting_io_part_2_input_with_tty_sl.html",
                  false,
                  617),
      Episode.new("193: Linting with Dogma",
                  "Examining an up and coming coding style enforcement tool.",
                  "193_Linting_with_Dogma_Screenshot",
                  "/episodes/193_linting_with_dogma.html",
                  false,
                  450),
      Episode.new("194: Interoperability - Ports",
                  "Writing a C program that has an Elixir interface by way of Erlang's Ports system.",
                  "194_Interoperability_Ports_Screenshot",
                  "/episodes/194_interoperability_ports.html",
                  false,
                  753),
      Episode.new("195: Spaceships",
                  "A rapid jaunt through a little spaceship simulator I wrote that has a wx renderer.",
                  "195_Spaceships_Screenshot",
                  "/episodes/195_spaceships.html",
                  false,
                  268),
      Episode.new("196: Crashing the BEAM",
                  "Causing a few of the BEAM's failure modes so we can see them in a controlled environment...and because breaking things is fun.",
                  "196_Crashing_the_BEAM_Screenshot",
                  "/episodes/196_crashing_the_beam.html",
                  false,
                  333),
      Episode.new("197: gproc",
                  "Using Ulf Wiger's `gproc` application to register processes and look them up in interesting ways.",
                  "197_gproc_Screenshot",
                  "/episodes/197_gproc.html",
                  false,
                  609),
      Episode.new("198: Elixir and Unity3D",
                  "Rendering our spaceships simulator in 3D with Unity3D",
                  "198_Elixir_and_Unity3D_Screenshot",
                  "/episodes/198_elixir_and_unity3d.html",
                  false,
                  184),
      Episode.new("199: Modeling a Virtual Machine",
                  "Building a register-based virtual machine with 4 registers and 2 instructions...And a bytecode format...And an assembly language.",
                  "199_Modeling_a_Virtual_Machine_Screenshot",
                  "/episodes/199_modeling_a_virtual_machine.html",
                  false,
                  1396),
      Episode.new("200: Custom Types in Ecto",
                  "Storing custom types in Ecto models...Specifically, storing a particularly-shaped 2-tuple, and barfing on anything else.",
                  "200_Custom_Types_in_Ecto_Screenshot",
                  "/episodes/200_custom_types_in_ecto.html",
                  false,
                  471),
      Episode.new("201: Tracing and Debugging with erlyberly",
                  "Tracing function calls in a running Erlang node, which should be massively helpful for debugging.",
                  "201_Tracing_and_Debugging_with_erlyberly_Screenshot",
                  "/episodes/201_tracing_and_debugging_with_erlyberly.html",
                  false,
                  213),
      Episode.new("202: Exception Monitoring with Honeybadger.io",
                  "Monitoring exceptions in your production applications, whether they're OTP applications, Phoenix applications, or something ad-hoc.",
                  "202_Exception_Monitoring_with_Honeybadger.io_Screenshot",
                  "/episodes/202_exception_monitoring_with_honeybadgerio.html",
                  false,
                  435),
      Episode.new("203: plug_auth",
                  "An unbelievably simple plug for adding authentication and role-based authorization to your Plug-based
web application.",
                  "203_plug_auth_Screenshot",
                  "/episodes/203_plug_auth.html",
                  false,
                  266),
      Episode.new("204: Behaviours",
                  "Enforcing your own custom interfaces with Behaviours in Elixir.",
                  "204_Behaviours_Screenshot",
                  "/episodes/204_behaviours.html",
                  false,
                  490),
      Episode.new("205: The Opposite of Mocks",
                  "A strategy that I employed to get around a module that was particularly opposed to being tested, due to a dependency on being started with a client socket as its argument.",
                  "205_The_Opposite_of_Mocks_Screenshot",
                  "/episodes/205_the_opposite_of_mocks.html",
                  false,
                  564),
      Episode.new("206: Getting a Nested Module From a String",
                  "A few unsafe ways to turn user input into a module, a wrongheaded safe way to do it, and then the correct way to do it.",
                  "206_Getting_a_Nested_Module_From_a_String_Screenshot",
                  "/episodes/206_getting_a_nested_module_from_a_string.html",
                  false,
                  271)
    ]
  end

  def specials
    {
      logo: [episodes[165], episodes[166]]
    }
  end
end

set :haml, format: :html5
set :css_dir, 'stylesheets'
set :js_dir, 'javascripts'
set :images_dir, 'images'

# Build-specific configuration
configure :build do
  # For example, change the Compass output style for deployment
  activate :minify_css

  # Minify Javascript on build
  activate :minify_javascript

  # Enable cache buster
  #activate :asset_hash

  # Use relative URLs
  # activate :relative_assets

  # Or use a different image path
  # set :http_path, "/Content/images/"
end
